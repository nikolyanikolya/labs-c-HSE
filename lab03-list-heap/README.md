# Лабораторная работа №3 (List Heap)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Поддерживаемые операции](#поддерживаемые-операции)
    1. [Невозможность копирования](#невозможность-копирования)
    1. [Гарантии](#гарантии)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Закрытые тесты](#закрытые-тесты)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте шаблон структуры данных «списко-куча» `list_heap` для произвольного типа `T` и компаратора `Compare` на основе `std::list`.

Списко-куча описана в конспекте по алгоритмам в разделе 7.5.
Это реализация [сливаемой кучи](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F_%D0%BA%D1%83%D1%87%D0%B0) (mergeable heap),
в которой все операции, кроме извлечения минимума, выполняются за константное время.
Извлечение минимума работает за линейное время.

Требуемая асимптотика достигается так: куча хранит внутри себя двусвязный список элементов
и итератор (указатель) на текущий минимум.
При извлечении текущего минимума ищется новый минимум полным перебором списка.

Точный набор поддерживаемых операций можно проверить через открытые тесты и проверить ниже в задании.

### Поддерживаемые операции
Интерфейс `list_heap` вдохновлён интерфейсом `std::priority_queue`.

Следующие операции должны работать за O(1) и O(1) вызовов `Compare::operator()`:

* `empty()` возвращает `true` тогда и только тогда, когда куча пуста.
* `push(T value)` добавляет в кучу элемент `value`.
* `top()` возвращает ссылку на минимальный элемент, содержащийся в куче. Если таких несколько, то возвращается ссылка на первый добавленный.
* `merge(list_heap other)` переносит все элементы из кучи `other` в текущую, порядок добавления сохраняется. Куча `other` становится пустой.

Следующая операция должна работать за O(n) и O(n) вызовов `Compare::operator()`, где n — количество элементов в куче:

* `pop()` удаляет из кучи минимальный элемент. Если таких несколько, то удаляется первый добавленный. Ничего не возвращает.

Гарантируется, что из пустой кучи никогда не запрашивается и не удаляется минимальный элемент.

### Невозможность копирования
Так как внутри списко-кучи требуется хранить и список, и итератор на элемент этого списка,
стандартная семантика копирования для `list_heap` не сработает: в копии итератор будет
указывать на элемент оригинального списка, а не скопированного.

Семантику можно переопределить (при помощи конструктора копирования и оператора копирующего присваивания),
однако в этом задании это не требуется.
Вам лишь требуется явно запретить любое копирование `list_heap`, при этом оставив
возможным перемещение и удаление (с семантикой по умолчанию).
Для этого добавьте следующий код внутрь определения класса:

```c++
list_heap(const list_heap &) = delete;
list_heap &operator=(const list_heap &) = delete;
list_heap(list_heap &&) noexcept = default;
list_heap &operator=(list_heap &&) noexcept = default;
~list_heap() = default;
```

### Гарантии
* Гарантируется, что тип `T` свободно копируется при помощи `operator=` (однако копия может быть дорогой операцией, поэтому их стоит делать поменьше).
  * Более строго, `T` удовлетворяет требованиям [`CopyConstructible`](https://en.cppreference.com/w/cpp/named_req/CopyConstructible), [`CopyAssignable`](https://en.cppreference.com/w/cpp/named_req/CopyAssignable), [`Destructible`](https://en.cppreference.com/w/cpp/named_req/Destructible).
* Гарантируется, что тип `Compare` свободно копируется  при помощи конструктора и любой экземпляр типа `Compare` имеет `operator()`, который можно вызвать от двух константных объектов типа `T`
  * Более строго, `T` удовлетворяет требованиям [`CopyConstructible`](https://en.cppreference.com/w/cpp/named_req/CopyConstructible), [`Destructible`](https://en.cppreference.com/w/cpp/named_req/Destructible).
  * Гарантируется, что `Compare` задаёт полный линейный порядок на экземплярах типа `T`, лежащих в куче в произвольный момент времени.

### Советы
* Метод `std::list::insert` копирует элементы из одного списка в другой.
  Как следствие, он работает за линейное время и для операции `merge()` не подойдёт, на это есть тест `lots of merge`.

## Требования к корректности решения
* Запрещается реализовывать список руками, используйте `std::list` и `std::list<>::iterator`.

### Стандартные требования
Действуют [стандартные требования](../common/).

### Закрытые тесты
В этом задании закрытых тестов не будет.
Набор открытых тестов уже должен быть очень хорош, но он всё ещё может расширяться.

Если какие-то открытые тесты добавлены после 22:59 понедельника (16 ноября), то
непрохождение конкретно этих тестов баллы в ноль не сбрасывает.

## Инструкция по сдаче
С этого задания действует вы сдаёте все лабораторные в одном конкретном репозитории,
в остальном процесс [практически не меняется](../common/).

## Сроки сдачи
Задание выдано 5 ноября 2020 (четверг). Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 12 ноября 2020 (четверг), **22**:59.
* **Гарантированный срок проверки:** 16 ноября 2020 (понедельник).
* **Дедлайн исправлений:** 19 ноября 2020 (четверг), **22**:59.
