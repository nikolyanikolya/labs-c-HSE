# Лабораторная работа №4 (Tic Tac Toe)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Архитектура приложения](#архитектура-приложения)
    1. [Автоматические тесты](#автоматические-тесты)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Требования к фреймворку автоматического тестирования](#требования-к-фреймворку-автоматического-тестирования)
    1. [Требования к промежуточной попытке](#требования-к-промежуточной-попытке)
    1. [Правила игры](#правила-игры)
    1. [Консольное приложение](#консольное-приложение)
    1. [Структура программы](#структура-программы)
1. [Советы](#советы)
1. [Бонусное задание](#бонусное-задание)
1. [Сроки сдачи и обновления условия](#сроки-сдачи-и-обновления-условия)
1. [Система оценки](#система-оценки)

## Задание
Реализуйте консольное приложение-игру крестики-нолики 10 на 10 (5 в ряд) для двух игроков.
Требуется два режима работы: по умолчанию перед каждым ходом на экран выводится поле (`./tic-tac-toe-loud`),
в _молчаливом_ режиме поле выводится только один раз в конце игры (`./tic-tac-toe-silent)`.
Проектируйте приложение таким образом, чтобы в будущем можно было без перекомпиляции
добавить третий режим — интерактивный интерфейс (см. [бонусное задание](#бонусное-задание)),
даже если не собираетесь его реально добавлять.

### Архитектура приложения
В архитектуре должны быть явно выделены классы "модель игры" и "отображение" (model-view);
первый отвечает за всю логику игры, второй — за конкретный формат ввода-вывода.
Это позволит:

* Написать и запустить много юнит-тестов на модель игры без запуска приложения.
* Потренироваться в проектировании расширяемых в будущем API.

Два режима должны отличаться только тем, что в одном при компиляции используется
файл `src/view_cli_loud.cpp`, а в другом — `src/view_cli_silent.cpp`.
Остальные файлы, в том числе заголовочные, можно даже не перекомилировать.

Таким образом, между файлами с реализациями двух режимов требуется совместимость не
только по API, но и по ABI.
Это должно получиться само собой.
Если у этих файлов появляется общая логика, вынесите её в отдельный файл,
чтобы убрать копипаст.

### Автоматические тесты
Также должен быть реализован собственный фреймворк `mytest` для юнит-тестирования
с макросами `TEST_CASE` и `CHECK`, ведущими себя похоже на соответствующие макросы из doctest.

Обязательно при помощи этого фреймворка написать автотесты для "модели" и "отображения", покрывающие весь код,
кроме, возможно, некоторых исключительных случаев вроде нарушения инвариантов в программе
или небольших "склеивающих" кусочков, которые очевидным образом полностью проверяются
интеграционными тестами из условия (то есть если в них допустить ошибку,
то работать перестанет сразу всё).
Лучше заранее обсудить с принимающим/преподавателем, что можно не покрывать.

Использовать `doctest` запрещается.
Для проверки "отображения" рекомендуется использовать `std::stringstream` и продумать API
так, чтобы не было привязки к `std::cin`/`std::cout`.

## Требования к корректности решения
### Стандартные требования
Действуют [стандартные требования](../common/).
Так как проект состоит из множества файлов в разных папках,
к некоторым командам потребуется добавить ключи `-I` (`-extra-arg=-I` в случае `clang-tidy`).
Прочие небольшие изменения вы можете посмотреть по истории изменений соответствующего файла.

Обратите внимание, что `clang-tidy` запрещает использовать макросы, однако они требуются
в `mytest.h`.
Также иногда возможны ложноположительные срабатывания в заголовках; например,
на неиспользуемые поля.
В этих случаях разрешается подавить соответствующее предупреждение в конкретной строчке.
На всякий случай лучше уточнять у проверяющего.

Решение собирается в четыре или больше файлов:

* `mytest/mytest-demo` — демонстрационное приложение для фреймворка автотестов.
* `tic-tac-toe-loud` и `tic-tac-toe-silent` — две версии игры: обычная и _молчаливая_.
* `tic-tac-toe-test` — запуск автотестов.
  Вы можете сделать больше файлов (например, если у вас отдельные тесты для обычной и _молчаливой_ версий),
  тогда их имена должны начинаться с `tic-tac-toe-test` (например, `tic-tac-toe-test-loud`).

Функциональность приложений не должна пересекаться.
Например, игре запрещается запускать тесты.

### Дополнительные требования
* Каждый публичный метод модели (класса `Game`) должен быть протестирован
  как минимум тремя тестовыми методами.
* В каждой библиотеке и исполняемом файле должно содержаться по минимуму объектных файлов и зависимостей.
* При компиляции должен быть виден минимальный набор заголовочных файлов: например,
  фреймворк для автотестов не должен видеть заголовки приложения.

### Требования к фреймворку автоматического тестирования
Пример в папке `mytest/demo` должен собираться и выводить в стандартный поток ошибок (не вывода!) отчёт
о выполненных тестах в следующем формате:
```
Running "Demo1.cpp test case 1"...
Running "Demo1.cpp test case 2"...
CHECK(2 * 2 == 5) at demo/demo1.cpp:8 failed!
Running "Demo2.cpp test case 1"...
Running "Demo2.cpp test case 2"...
CHECK(2 * 2 == 5) at demo/demo2.cpp:8 failed!
Running "Demo2.cpp test case with multiple failures and messages"...
CHECK(2 * 2 == 5) at demo/demo2.cpp:13 failed!
    message: demo2-msg2
CHECK(2 * 2 == 5) at demo/demo2.cpp:15 failed!
===== Tests passed: 2/5 =====
```
или, например:
```
Running "Demo2.cpp test case 1"...
Running "Demo2.cpp test case 2"...
CHECK(2 * 2 == 5) at demo/demo2.cpp:8 failed!
Running "Demo2.cpp test case with multiple failures and messages"...
CHECK(2 * 2 == 5) at demo/demo2.cpp:13 failed!
    message: demo2-msg2
CHECK(2 * 2 == 5) at demo/demo2.cpp:15 failed!
Running "Demo1.cpp test case 1"...
Running "Demo1.cpp test case 2"...
CHECK(2 * 2 == 5) at demo/demo1.cpp:8 failed!
===== Tests passed: 2/5 =====
```

* Тесты внутри файла должны выполняться в порядке объявления.
  Порядок выполнения тестов между разными файлами произвольный (в соответствии со [static initialization order fiasco](https://isocpp.org/wiki/faq/ctors#static-init-order)).
* Тестовое приложение должно завершаться с нулевым кодом возврата тогда и только тогда, когде все тесты пройдены.
* Строго соблюдайте формат вывода.
  * Допускается выводить полный путь к файлу, не требуется как-то обрабатывать результат подстановки `__FILE__`.
* Фреймворк не должен требовать от пользователя как-то определять тесты, кроме как `TEST_CASE` — см. пример в папке `mytest/demo`.
* `main()` в тестах реализуется в отдельном файле `mytest_main.cpp`, который включается в отдельную библиотеку `mytest-main`.
  Таким образом в основной программе можно определять тесты вперемешку с кодом, всё будет компилироваться, но тесты просто не будут запускаться.
  А вот если слинковать с `mytest-main`, то запустятся.

### Требования к промежуточной попытке
* [Структура программы](#структура-программы) близка к корректной.
* Полностью работает демонстрационное приложение для фреймворка автотестов.
* Отклонения от формата ввода-вывода не допускаются.
* Допускается неидеальное разделение по файлам.
* Допускается некорректная обработка некоторых крайних случаев.
* Нельзя UB (но на усмотрение преподавателя иногда можно, уточняйте).

### Правила игры
Игра ведется на игровом поле — квадрат 10 на 10 клеток.
Один игрок играет крестиками, второй — ноликами.

Первыми начинают _нолики_.
Игроки ходят по очереди.
В свой ход игрок может поставить на свободную клетку свой знак.

Целью игры является выставить 5 своих знаков в ряд по вертикали, горизонтали или любой из двух диагоналей.
Выигрывает тот игрок, который сделает это первым.
Если свободных клеток на игровом поле не осталось, то назначается ничья.

### Консольное приложение
При запуске приложение сразу начинает единственную игру с управлением через консоль.

Исходно поле пустое.
В начале каждого хода выводится игровое поле и приглашение: <code>X move:&nbsp;</code> — для крестиков и <code>O move:&nbsp;</code> — для ноликов (нолики обозначаются латинской буквой «O»).
Обратите внимание на пробел после двоеточия.
В ответ на приглашение пользователь должен ввести параметры хода — два числа (строка и столбец, числа от 0 до 9) через пробел, после чего перевод строки.
Если введен некорректный ход (например, некорректный формат чисел, клетка занята и т.д.), то выводится сообщение `Bad move!`, затем ход запрашивается повторно (приглашение выводится еще раз, доску выводить не нужно).
Также пользователь в ответ на приглашение может ввести два числа -1 и -1, в этом случае
программа должно немедленно корректно завершиться без дополнительных сообщений.

Если пользователь добавляет лишние ведущие нули и/или пробельные символы до/после/между числами,
это всё ещё считается корректным ходом или командой завершения.
Гарантируется, что в ответ на приглашение пользователь вводит строчку из произвольных символов с ASCII-кодами от 32 до 127,
завершённую ровно одним символом перевода строки.

Если после хода партия закончилась, то на экран выводится (в отдельной строчке после игрового поля) один из результатов игры: `X wins!`, `O wins!` или `Draw.`,
после чего программа корректно завершается.

По умолчанию в начале каждого хода на экран выводится игровое поле.
В _молчаливом_ режиме игровое поле выводится только один раз после окончания игры (перед надписью с результатом игры).
Доска должна вводится в виде строк из символов, описывающих клетки (`X` — буква «X», крестик; `O` — буква «O», нолик; `.` — точка, незанятая клетка), например:
```
XXXX.....O
XOXOXOXOXO
X........O
O........X
OXOXOXOXOX
XXXX.....O
XOXOXOXOXO
X........O
O........X
OXOXOXOXOX
```

Пример партии. Обратите внимание на переводы строк и пробелы.

|Ввод|Вывод|
|:---|:----|
| |`​` _(здесь и далее: пустая строчка)_<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code> _(здесь и далее без перевода строки)_|
|`1 1`|`​`<br/>`..........`<br/>`.O........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>X move:&nbsp;</code>|
|`0 0`|`​`<br/>`X.........`<br/>`.O........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code>|
|`0 0`|`Bad move!`<br/><code>O move:&nbsp;</code>
|`1 0`|`​`<br/>`X.........`<br/>`OO........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code>| 
|`0 1`| _ходы опущены_
|_ходы опущены_|`​`<br/>`XXXX......`<br/>`OOOO......`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/><code>O move:&nbsp;</code>|
|`1 4`|`​`<br/>`XXXX......`<br/>`OOOOO.....`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O wins!` _(с переводом строки)_|

Доступна [запись работы в терминале](https://asciinema.org/a/xUrsyAeHAXQUBiDXlK1eC0qNE) для этого примера.
Также эту запись можно просмотреть с помощью команды `asciinema play cli-demo.asciinema`.
На записи также есть демонстрация _молчаливого_ режима.

### Структура программы
* Модель представлена классом `Game`, описывает логику игры и её внутреннее представление.
  Реализована в файле `game.cpp`.
  * Модель должно быть можно без изменений использовать в схожих программах для
    игры в крестики-нолики.
  * Например, модель обязательно должна хранить состояние поля, позволять делать ходы
    и узнавать текущее состояние игры: чей ход, кто выиграл.
* Заглушки для некоторых классов предоставлены в файлах рядом с `README.md`.
  Используйте их как пример.
  Разрешается добавлять свои методы, удалять или менять имеющиеся,
  но всегда думайте про архитектуру.
  Например, ABI-совместимость между разными версиями `view_cli_*`.

## Советы
* Корректно считать два числа из строки со случайными данными — это сложно, там много крайних случаев.
  Но делается при помощи стандартных `<iostream>`.
  Внимательно поэкспериментируйте с тем, как она работает.
  * Например, если при помощи `std::stringstream` из строчки `1234foo` прочитать `int`, то прочтается число `1234` — максимальный префикс-число.
  * При этом `4 4foo` не является корректным ходом, равно как и `1row1column`, а вот `0 -0` — является.
* Пишите побольше тестов, чтобы точно не было проблем с алгоритмической частью задания.
* При возможности используйте и пишите forward-заголовки.
* Используйте include guards.
* Используйте `namespace tictactoe`.
* Используйте anonymous namespaces, чтобы нельзя было случайно слинковаться с функцией из другого файла.
  Особенно актуально в фреймворке для автотестов.
* Заведите `enum class OptionalPlayer`, хранящий в себе одно из трёх значений: ничего, крестики, нолики.
* Чтобы лучше понять, как именно запускаются команды, посмотрите на файл с настройками (`lab04-tic-tac-toe.yml`) и на логи запуска автопроверок.
  Там выводятся в точности все запускаемые команды.
* Добавляйте свои собственные тесты на крайние случаи рядом с предоставленными.
  Тогда они будут запускаться автоматически и вы не получите внезапную регрессию.
  * Если вы случайно сломали свои тесты в момент дедлайна — ничего страшного, напишите об этом в комментарии
    и сделайте рядом коммит с отключёнными тестами, чтобы было видно, что на самом деле наши автопроверки пройдены.

## Бонусное задание
Реализуйте ещё один режим: интерактивная игра.
Предлагается использовать библиотеку `ncurses` (пакет в Ubuntu: `libncurses5-dev`; под Windows аналога, к сожалению, нет).
Она позволит нарисовать интерфейс с окошками в консоли.

В отличие от варианта на стандартном вводе-выводе, игровое поле все время перерисовывается на одном и том же месте.
Формат вывода игрового поле в целом такой же как и основного режима.
Ход осуществляется с помощью клавиш управления: влево, вправо, вверх, вниз и пробел (поставить крестик или нолик).
Клавиша `x` — досрочный выход из программы.

Управление должны быть устроено таким образом, чтобы нельзя было выйти за пределы доски или ввести некорректный ход.
При этом никаких сообщений об ошибке на экран не выводится.
Сообщение о результате партии должно быть такое же как и у основного режима.

Здесь специально нет точных указаний, что сделать, вам даётся свобода.
Сделайте как вам покажется удобным, _но не заигрывайтесь_.

Важно: замена стандартного режима на интерактивный не должна требовать перекомпиляции
других файлов, только перелинковки.

## Сроки сдачи и обновления условия
Задание выдано 19.11.2019 (четверг).
На задание даётся **ровно три** попытки сдачи со следующими сроками сдачи:

1. **26.11.2020 (четверг) 22:59 по Москве**.
    * До этого момента всё ещё может меняться условие, хотя мы постараемся вносить только уточняющие правки,
      ничему не противоречащие.
    * Никаких санкций за то, что вы следовали исходному условию, не должно быть.
1. **03.12.2020 (четверг) 22:59 по Москве** — промежуточный срок сдачи.
1. **10.12.2020 (четверг) 22:59 по Москве** — крайний срок сдачи
   (требуется выполнить [требования к промежуточной попытке](#требования-к-промежуточной-попытке),
   чтобы получить возможность сдавать до крайнего срока).

Если проверка задерживается, дедлайны двигаются по договорённости с преподавателем.

Учтите, что в отличие от предыдущих домашек:

* Это домашнее задание больше по объёму кода.
  Пожалуйста, не откладывайте даже до второго срока сдачи.
* Вам снова придётся вспомнить git, и даже несколько раз.
* Следствие большого объёма и разнообразия: наверняка в текущей версии
  условия есть неточности и недоговорки.
  Активно взаимодействуйте с практиками, задавайте вопросы по условию.
* Вы можете сделать **не больше трёх** полноценных попыток за всё время сдачи.
  На усмотрение преподавателя могут добавляться промежуточные попытки,
  которые будут проверяться частично.

## Система оценки
* Задание оценивается в 30 баллов: 20 за корректность, 10 за стиль.
* Вы можете получить ещё +10 баллов за [бонусное задание](#бонусное-задание), итого 40.
