# Лабораторная работа №5 (Pointers)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Поддерживаемые операции](#поддерживаемые-операции)
    1. [Гарантии](#гарантии)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Закрытые тесты](#закрытые-тесты)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте два шаблона умных указателей: `unique_ptr` и `shared_ptr`,
являющиеся упрощениями соответствующих шаблонов из `std::`.

`unique_ptr` должен быть move-only, поддерживать как обычные типы, так и массивы,
а также использовать произвольный функтор для удаления объекта.
Вы также должны самостоятельно реализовать функтор по умолчанию,
похожий на `std::default_delete`, который будет корректно вызывать
с `delete` и `delete[]` в зависимости от того, является ли переданный
тип массивом или нет.

`shared_ptr` должен поддерживать только обычные типы, поддержка
массивов не требуется, поддержка произвольных функторов для удаления не требуется.

Не требуются преобразования между указателями на разные типы или
между `unique_ptr`/`shared_ptr`.

Точный набор поддерживаемых операций можно проверить через открытые тесты и проверить ниже в задании.

### Поддерживаемые операции
Оба умных указателя должны иметь:

* Конструктор по умолчанию.
* Конструктор от указателя, который требуется взять во владение.
* Перемещающий оператор присваивания.
* Перемещающий конструктор.
* Метод `get()` для получения текущего значения указателя.
* Метод `reset()`, сбрасывающий текущий указатель.
* Метод `reset(x)`, передающий владение обычным указателем `x` умному указателю.
* Перегруженные операторы `->` и `*`.
* Свободную функцию `swap()`.
* Явный оператор приведения к `bool`.
* Операторы `==` и `!=` для сравнения умных указателей одного типа.

Даже если сам указатель константный, то данные, на которые он указывает, могут быть неконстантны
(а можно и `shared_ptr<const int>` сделать).

`unique_ptr` также должен иметь:

* Конструктор от указателя, который требуется взять во владение, и удаляющего функтора.
* В случае владения массивом — перегруженный оператор `[]`.
  Разрешается реализовать его и в случае владения одним объектом.
* Метод `release()`, "открепляющий" указатель от умного указателя и возвращающий его.

`shared_ptr` также должен иметь:

* Копирующий оператор присваивания.
* Копирующий конструктор.

### Гарантии
TODO

### Советы
* Так как указатель (`T*`) и указатель на массив (`T(*)[]`) — несовместимые типы,
  то просто так использовать `T*` внутри `unique_ptr<T>` при `T=int[]` нельзя:
  это будет указатель на массив, а в интерфейсе `unique_ptr` везде предполагается
  указатель на объект.
  Чтобы с этим справиться, воспользуйтесь приватным `using`/`typedef`
  и вспомогательным type trait `std::remove_extent_t`.
* Используйте `std::exchange` для упрощения кода.
* Закомментируйте тесты, начните с простой реализации `unique_ptr`,
  и двигайтесь от простого к сложному, раскомментируя тесты по очереди.

## Требования к корректности решения
* Запрещается использовать стандартные умные указатели и `std::default_delete`.

TODO

### Стандартные требования
Действуют [стандартные требования](../common/).

Однако флаги для статических проверок несколько изменены:

* У `clang-tidy` отключены следующие проверки:
  * `cppcoreguidelines-owning-memory`
  * `performance-noexcept-move-constructor`
  * `bugprone-unhandled-self-assignment` (из-за бага https://bugs.llvm.org/show_bug.cgi?id=48310)

### Закрытые тесты
В этом задании закрытых тестов не будет.
Набор открытых тестов уже должен быть хорош, но он ещё будет расширяться
(можете посмотреть на `TODO` в тестах).

Если какие-то открытые тесты добавлены после 22:59 вторника (1 декабря), то
непрохождение конкретно этих тестов баллы в ноль не сбрасывает.

## Инструкция по сдаче
[Как и раньше](../common/), вы должны самостоятельно синхронизировать ветку
`master` в своём репозитории, создать новую ветку для задания и новый Pull Request.

## Сроки сдачи
Задание выдано 27 ноября 2020 (пятница). Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 4 декабря 2020 (пятница), **22**:59.
* **Гарантированный срок проверки:** 8 декабря 2020 (вторник).
* **Дедлайн исправлений:** 11 декабря 2020 (пятница), **22**:59.
