# Лабораторная работа №6 (Employees)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Формат ввода-вывода](#формат-ввода-вывода)
    1. [Формулы зарплат](#формулы-зарплат)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Закрытые тесты](#закрытые-тесты)
1. [Бонусное задание](#бонусное-задание)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте иерархию полиморфных классов `Employee`, `Developer`, `Manager`, `LeadDeveloper`,
хранящих информацию о сотрудниках некоторой компании,
а также игрушечную базу данных, хранящую упорядоченный список сотрудников.

Каждый сотрудник — либо разработчик, либо менеджер, либо ведущий разработчик
(совмещающий свойства разработчика и менеджера).

Каждым классом должна поддерживаться (де)сериализация при помощи `operator<<` и статического метода `Employee::read_from()`.
Предполагайте, что формат строгий, меняться практически не будет, нужно сохранять/загружать все поля, и можно пользоваться наследованием.

Игрушечная база данных должна поддерживать команды:

* `load <имя-файла>` — замена текущего списка сотрудников на список из файла
* `save <тип> <имя-файла>` (где `<тип>` — одно из `all`, `developers`, `managers`, `leads`) — сохранение подмножества сотрудников в файл
* `list-devs` — вывод на экран списка сотрудников, являющихся разработчиками (то есть `Developer` и `LeadDeveloper`)

### Формат ввода-вывода
* Гарантируется, что каждая строчка стандартного входа содержит корректную команду без пробельных символов и символов с кодами меньше 32 или больше 127.
  * Гарантируется, что имена файлов не содержат пробельных символов.
* Все строки из информации о сотрудниках (имена, ники, проекты):
  * Не короче одного символа.
  * Не длиннее 1000 символов.
  * Не содержат символов с кодами меньше 32 или больше 127.
  * У имени сотрудника есть исключения: допускаются пробелы, но не допускаются тильды (`~`).
* Точный формат файлов и вывода команды `list-devs` смотрите в автоматических тестах.
  * Для упрощения кода при сохранении полного имени в файл вы обязаны заменить все пробелы на тильды (`~`), а при загрузке — наоборот.
    * Это костыль, так делать не очень хорошо (я не уверен, что тильда никогда не является разумной частью имени), по-хорошему надо делать полноценное экранирование,
      но это выходит за рамки задания.
    * При этом на экран имя должно выводиться с пробелами.
  * Гарантируется, что все файлы на входе корректны, нет пустых строк, все числа от нуля до миллиона.
  * Ваши сохранённые файлы также должны удовлетворять гарантиям из предыдущего пункта.
* Порядок сотрудников важен, его нельзя менять.

### Формулы зарплат
* Разработчик: базовая зарплата плюс 100 долларов в год за каждый `char` в имени GitHub-аккаунта.
* Менеджер: базовая зарплата плюс 100 долларов в год за каждый `char` в имени проекта.
* Ведущий разработчик:
  * Базовая зарплата.
  * 150 долларов в год за каждый `char` в имени GitHub-аккаунта.
  * 80 долларов в год за каждый `char` в имени проекта.

### Советы
* Реализуйте себе вспомогательные функции для чтения из потока.
* Отдельно подумайте про публичный интерфейс для каждого класса, и отдельно — про защищённый.

## Требования к корректности решения
### Стандартные требования
Действуют [стандартные требования](../common/).

Однако флаги для статических проверок несколько изменены:

* У `clang-tidy` отключены следующие проверки:
  * `misc-non-private-member-variables-in-classes
  * `bugprone-exception-escape`

### Дополнительные требования
* Запрещается создавать лишние поля. Вместо этого используйте наследование.
* Используйте множественное наследование, а не [более разумные в данном случае альтернативы](https://isocpp.org/wiki/faq/multiple-inheritance#mi-disciplines)
  * Например, не разрешается использовать паттерн «мост» или хранить у каждого сотрудника список ролей, хотя второе решение было бы в данной задаче и проще, и лучше масштабировалось.
  * Без множественного наследования у вас не должны компилироваться тесты, использующие `dynamic_cast<>` с указателями.
* Запрещается дублировать код сериализации/десериализации, даже если это просто `os << full_name;`.
* За пределами классов из `employee::` должно быть нельзя случайно сделать что-то не так. Например, вызвать какой-то хитрый конструктор вместо `read_from`.
* Запрещается реализовывать методы в `.h`, реализуйте их в `.cpp`.
* Обращения к полям должны возвращать реальные значения.
  В частности, нельзя хранить тильды в полных именах.

## Бонусное задание
За каждое из требований ниже вы можете получить +0.5 бонусного балла за корректность и +0.5 бонусного балла за стиль:

* Все поля в вашей реализации классов из `employee::` константны.
* Вы реализовали вывод при помощи паттерна проектирования Посетитель (Visitor).

## Инструкция по сдаче
[Как и раньше](../common/), вы должны самостоятельно синхронизировать ветку
`master` в своём репозитории, создать новую ветку для задания и новый Pull Request.

## Система оценки
* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете получить ещё +2 балла за [бонусное задание](#бонусное-задание), итого 12.

## Сроки сдачи
Задание выдано 4 февраля 2021 (четверг). Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 13 февраля 2021 (суббота), **22**:59.
* **Гарантированный срок проверки:** TODO.
* **Дедлайн исправлений:** TODO.
