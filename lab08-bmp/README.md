# Лабораторная работа №8 (BMP)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Формат входных и выходных изображений](#формат-входных-и-выходных-изображений)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Консольное приложение](#консольное-приложение)
    1. [Обработка ошибок](#обработка-ошибок)
    1. [Структура программы](#структура-программы)
    1. [Тесты](#тесты)
1. [Бонусное задание](#бонусное-задание)
    1. [Советы](#советы)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте приложение `./bmp`, которое вырезает прямоугольник из входного BMP-файла с изображением,
поворачивает этот прямоугольник на 90 градусов по часовой стрелке и сохраняет результат в отдельный выходной файл.

Вход либо уже является файлом на диске, либо его требуется скачать из
интернета при помощи своей RAII-обёртки над `libcurl`.

### Формат входных и выходных изображений
Все изображения хранятся в заданном формате:

* Общий формат — [BMP](https://ru.wikipedia.org/wiki/BMP).
* В рамках формата BMP используется формат *DIB* с заголовком `BITMAPINFOHEADER` (версия 3).
* Значение поля `biHeight` (высота изображения) строго больше нуля.
* Значение поля `biSizeImage` (количество байт, хранящих изображение) строго больше нуля.
* Используются 24 бита цвета на пиксель (один байт на цветовой канал в [модели RGB](https://ru.wikipedia.org/wiki/RGB)).
* Палитра (таблица цветов) не используется.
* Сжатие не используется.

Таким образом, вам требуется обработать лишь один конкретный вид BMP,
не требуется поддерживать все возможности формата.

В качестве примера входного файла вам даны [`lena-512.bmp`](./test-data/lena-512.bmp) и [`small-one.bmp`](./test-data/small-one.bmp).
Также некоторые графические редакторы могут генерировать изображение в нужном формате
(«24-битное изображение BMP»), проверяйте поля в заголовках.

#### Требования к выходному изображению
1. Выходное изображение должно содержать ту же информацию в заголовках, что и входное, кроме тех, что необходимо изменить (например, размеры).
2. Все байты, используемые для выравнивания данных вне заголовков — нули.

### Советы
* Чтобы посмотреть байты, можете использовать команду `hexdump -C small-one.bmp` (не путать с `hexdump small-one.bmp`).
* Сначала научитесь читать `small-one.bmp` при помощи hex-редактора, а уже потом пытайтесь его прочитать в коде.
* Сначала выпишите алгоритм для поворота изображения на 90 градусов на бумаге, а уже потом реализуйте его.
* Убедитесь, что вы корректно работаете с неквадратными изображениями.
* Убедитесь, что вы корректно работаете с изображениями со стороной, не делящейся на 4 (и при чтении, и при записи).
* Убедитесь, что вы открываете файл в режиме для бинарного ввода-вывода (`std::ios::binary`), это
  влияет на баллы за корректность.
  Вывод `\n` отличается под Windows и Linux, и, строго говоря, вывод некоторых символов в текстовом режиме — UB.
* Если хотите повеселиться, сначала сделайте бонус с Telegram-ботом, а потом транслируйте свои попытки
  решить задачу в реальном времени.
* Убедитесь, что вы не бросаете исключения из кода на C++ в сишную библиотеку `libcurl`.
* Отнаследуйте исключения от `std::runtime_error`, чтобы появился конструктор
  от `std::string` и вы смогли сделать произвольные сообщения об ошибках.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/); туда **добавилось требование** корректно компилироваться и работать под Visual Studio на Windows 10.

Однако флаги для статических проверок несколько изменены:

* У `clang-tidy` отключены следующие проверки:
  * `cppcoreguidelines-pro-bounds-pointer-arithmetic` (какая-то арифметика указателей может быть полезна при работе с изображениями).
  * `cppcoreguidelines-pro-type-reinterpret-cast` (нужен в нескольких местах).
  * `cppcoreguidelines-pro-type-vararg` (требуется для вызова небезопасной `curl_easy_setopt`).

### Дополнительные требования
* Ваше приложение не должно использовать памяти больше, чем занимают входной и выходной файл в сумме.
  * Считаем, что `vector<>` выделяет памяти ровно столько, сколько попросили.
  * Например, если оба изображения имеют размер `N*M` пикселей и дополнительного выравнивания не требуется,
    то завести три `vector<char>` размером `3*N*M` байт нельзя, а вот два — можно.
  * По стилю: работать с данными из памяти обычно проще, чем из файла
    (про memory-mapped files мы ещё не знаем, к тому же под Linux/Windows соответствующие функции называются по-разному),
    поэтому наверняка проще считать файл в память целиком, чем пытаться читать лишь по необходимости.
* Запрещается создавать файлы на диске, кроме выходного.
  В частности, файл из интернета надо скачивать прямо в память.
* Запрещается вызывать функции `libcurl`, кроме как внутри вашей RAII-обёртки.
* На создание изображения требуется константное количество выделений памяти.
  * Например, нельзя использовать для хранения `vector<vector<T>>`.
* Помните, что обращаться к массиву `char`'ов, как к объектам типа `T`, если не вызван placement new — UB.
  * Также обязательно надо вызывать деструкторы.
  * Если конструктор/деструктор у `T` пустой, компилятор это наверняка соптимизирует.
  * Это требуется сделать, несмотря на то, что на практике вряд ли выстрелит:
    так все всегда делали, да и в C++20 появился [P0593R6](http://wg21.link/p0593r6).
* Копировать байты в существующих объекты удобно при помощи [`std::memcpy`](https://en.cppreference.com/w/cpp/string/byte/memcpy).
* Ввод-вывод фиксированных структур формата BMP идёт напрямую при помощи `istream::read`/`ostream::write`
  и похожих механизмов, а не побайтовым считыванием в цикле.
* Чтение или запись одного BMP-файла требует константное количество вызовов операций ввода-вывода.
* Все сущности должны по максимуму объявляться в своих `.cpp`, а не заголовках.

### Консольное приложение
Приложение запускается одной из следующих команд:

```
./bmp crop-rotate          ‹in-file› ‹out-file› ‹x› ‹y› ‹w› ‹h›
./bmp download-crop-rotate ‹in-url›  ‹out-file› ‹x› ‹y› ‹w› ‹h›
```

Используемые параметры:

* `crop-rotate` или `download-crop-rotate` — обязательный параметр, означающий выполняемое действие.
  В первом случае входной файл лежит на диске, во втором случае его надо скачать.
* `in-file` — имя входного файла с изображением.
* `in-url` — URL, по которому доступен входной файл с изображением.
* `out-file` — имя выходного файла с изображением.
* `x`, `y` — координаты левого верхнего угла области, которую необходимо вырезать и повернуть. Координаты начинаются с нуля, таким образом *(0, 0)* — это верхний левый угол.
* `w`, `h` — соотвественно, ширина и высота области до поворота.

Таким образом, если обозначить ширину и высоту исходного изображения за `W` и `H`, соответственно, верны следующие неравенства:

* `0 <= x < x + w <= W`
* `0 <= y < y + h <= H`

Стандартный поток вывода остаётся пустым.

### Обработка ошибок
При возникновении следующих ошибок приложение обязано завершиться с кодом возврата 1 и выдать в стандартный
поток ошибок соответствующее сообщение (формат важен).

| Категория | Ошибка | Пример сообщения | Комментарий |
| --- | --- | --- | --- |
| Недостаточно аргументов | | `Missing arguments` | Проверяйте `argc` |
| Не удалось открыть файл `a.bmp` на диске (на чтение или запись) | | `Unable to open file "a.bmp"` |
| Неудачный HTTP-запрос | HTTP-запрос завершился с кодом 404 | `Server responded 404: page not found` | Используйте `CURLINFO_RESPONSE_CODE` |
| Неудачный HTTP-запрос | HTTP-запрос завершился с кодом `X` (любым, кроме 200) | `Server responded 500` |
| `libcurl` вернул ошибку при запросе | | `libcurl error: Couldn't resolve host name` | Используйте `curl_easy_strerror` |
| Неверный формат BMP | Не та версия | `Invalid BMP: expected version 3 and header size 40, but header size is 108` | |
| Неверный формат BMP | Неположительная высота | `Invalid BMP: expected positive biHeight, got -123` | |
| Неверный формат BMP | Не то количество бит на пиксель | `Invalid BMP: expected 24 bits per pixel, got 8` | |
| Неверный формат BMP | Используется сжатие | `Invalid BMP: compression is unsupported` | |
| Неверный формат BMP | Используется палитра | `Invalid BMP: color palette is unsupported` | |
| Неверные аргументы | Область для вырезания не лежит внутри изображения | `The requested area is not a subimage` | Переполнений `int` не будет, с запасом |
| Недостаточно памяти | | `Insufficient memory` | В C++ ловите `std::bad_alloc`, а код на Си у вас только в `libcurl`, это ошибка выше |

Гарантируется, что:

* За запуск программы произойдёт не более одной ошибки.
* Не будет ошибок кроме перечисленных выше.
  * Например, если аргументов достаточно, то `x`/`y`/`w`/`h` являются корректными целыми числами, помещающимися в `int` с запасом.
  * Гарантируется, что `curl_easy_init` всегда завершается удачно.
    Остальные функции либо всегда завершаются успешно и возвращают `void`, либо возвращают код ошибки, который можно проверить.
* Входной файл имеет размер хотя бы 54 байта.
  В частности, значение поле `bfSize` не меньше 54.
* Пиксельные данные начинаются сразу после заголовков,
  то есть значение поля `bfOffBits` совпадает с суммарным размером заголовков.

### Структура программы
* Должен быть создан отдельный класс для работы с изображениями
  и минимум двумя отдельными методами: `crop` (вырезание фрагмента) и `rotate_clockwise` (поворот на 90 градусов).
  * Если будете копировать, осторожно с потребляемой памятью.
  * Связывать этот класс с форматом BMP-файлов допустимо, но необязательно.
    Осторожно с памятью.
* Должен быть создан отдельный RAII-класс, оборачивающий используемые функции `libcurl`.
  Его методы должны как можно точнее отображать функции `libcurl`, но в стиле C++:
  * Вместо одного метода для `curl_easy_setopt` сделайте отдельные методы на каждый вид опций,
    чтобы получить проверку аргументов: в Си `curl_easy_setopt` вообще не проверяет типы аргументов.
  * Устанавливайте `CURLOPT_WRITEFUNCTION` и `CURLOPT_WRITEDATA` одним методом.
    Например, чтобы можно было передавать в качестве callback'а лямбда-функции с захватом
    (осторожно с временем жизни).
    * Вам может пригодиться тип `curl_write_callback`.
    * По стилю: лямбда-функции будет удобнее принимать `std::string_view`, чтобы избежать копирований и не передавать отдельно массив и размер массива.
* Разбор аргументов и обработка ошибок (вывод на экран) должны производиться только в `main.cpp`.
  * В частности, класс для работы с изображениями и функции ввода/вывода не имеют права выводить что-то на экран или завершать программу.
* Для обработки ошибок используйте исключения.
  * По типу пойманного исключения должно быть можно определить категорию ошибки.
  * Если поймано исключение вашего типа, то его `what()` должно совпадать с сообщением об ошибке, которое выводится на экран.

### Тесты
Добавлять тесты необязательно, но если вы это делаете, они должны собираться в исполняемый файл `./bmp-test`.

## Бонусное задание
Реализуйте дополнительную команду `crop-rotate-post`:

```
./bmp crop-rotate-post ‹in-bmp› ‹telegram-bot-api-url› ‹telegram-chat-id› ‹x› ‹y› ‹w› ‹h›
```

Она работает как и `crop-rotate`, но выходное изображение постит в
Telegram-группу/канал с номером `telegram-chat-id` от имени бота.
Параметр `telegram-bot-api-url` — это [путь к серверу Telegram Bot API](https://core.telegram.org/bots/api#making-requests), включающий
в себя токен бота, но не включающий имя метода, например: `https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11`.

Изображение отправляется при помощи метода [`sendPhoto`](https://core.telegram.org/bots/api#sendphoto) Telegram Bot API.
Он вызывается отправкой POST-запроса на определённый адрес с типом содержимого `multipart/form-data`.
Вам потребуется указать параметр `chat_id`, равный `telegram-chat-id`, а также передать содержимое файла в параметр `photo`.

В документации libcurl есть пример [postit2](https://curl.se/libcurl/c/postit2.html), в котором похожим
образом отправляется POST-запрос на адрес `https://example.com/examplepost.cgi` с
текстовым параметром `filename` и содержимым файла в параметре `sendfile`
(параметр `submit` не требуется).
Соответствующие методы `libcurl` требуется добавить в вашу RAII-обёртку.
Скорее всего, придётся добавить RAII-обёртки и для новых типов `curl_mime`, `curl_mimepart`, `curl_slist`.

### Советы
Для отладки вам потребуется создать бота, для этого напишите [@BotFather](https://t.me/BotFather).
Он выдаст токен, держите токен секретным и не кладите его в репозиторий, иначе кто угодно сможет работать от имени вашего бота.
Перед токеном нужно дописать `https://api.telegram.org/bot` и вы получите параметр `telegram-bot-api-url`.

Значение можно `telegram-chat-id` можно узнать, написав боту или добавив его в группу, после чего
посмотрев последние события бота при помощи метода [`getUpdates`](https://core.telegram.org/bots/api#getupdates).

Отлаживать запросы удобно при помощи консольной утилиты `curl`, рекомендуется это сделать перед
реализацией через `libcurl`.

```bash
curl https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/getUpdates  # GET-запрос
curl -F some_field=123 -F some_file=@my_file.bmp https://example.com  # POST-запрос с multipart/form-data
```

Если вам хочется поподробнее узнать про ботов, вы можете ознакомиться с
[официальной документацией](https://core.telegram.org/bots) или [обзорной статьёй](https://habr.com/ru/post/543676/).

## Инструкция по сдаче
[Как и раньше](../common/), вы должны самостоятельно синхронизировать ветку
`master` в своём репозитории, создать новую ветку для задания и новый Pull Request.

## Система оценки
* Задание оценивается в 14 баллов: 8 за корректность, 6 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете получить ещё +4 балла за [бонусное задание](#бонусное-задание), итого 18.

## Сроки сдачи
Задание выдано 6 марта 2021 (суббота) и обновлено 9 марта 2021 (вторник).
Ниже в каждом случае указано московское время.

* **Дедлайн прохождения автотестов:** 15 марта 2021 (понедельник), **22**:59.
  * К этому дедлайну вы имеете право закомментировать автотесты,
    проверяющие обработку ошибок или работу с `libcurl`.
  * Если к этому дедлайну не пройдены даже частично закомментированные автотесты,
    вы получите только половину баллов за задание.
* **Дедлайн сдачи:** 20 марта 2021 (суббота), **22**:59.
  * К этому дедлайну все автотесты должны быть возвращены в исходное состояние.
* Ожидайте проверку первой попытки в течение недели после дедлайна сдачи.
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений.
  * Дедлайн исправлений обговаривается индивидуально с проверяющим, в общем случае хотя бы пять суток.
  * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
