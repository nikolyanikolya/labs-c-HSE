# Лабораторная работа №10 (bank)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
    1. [Лирическое отступление](#лирическое-отступление)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Гроссбух](#гроссбух)
    1. [Блокирующий итератор](#блокирующий-итератор)
    1. [Сетевой сервер](#сетевой-сервер)
1. [Бонусное задание](#бонусное-задание)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Это задание состоит из трёх частей, вы можете выполнить только префикс и [получить частичные баллы](#система-оценки).

1. **Гроссбух**.
   Напишите потокобезопасные классы `bank::ledger` (гроссбух), `bank::user`, `bank::transaction`, представляющие игрушечный банк.
   Каждый пользователь:
    * Имеет уникальное имя.
    * Может получить свой текущий баланс в валюте `XTS` и историю транзакций.
    * Создаётся в момент первого обращения и получает 100 XTS (это такая [тестовая валюта из ISO 4217](https://en.wiktionary.org/wiki/XTS)).
    * Может перевести любому другому пользователю валюту.
    * Если при переводе возникает логическая ошибка,
      выбрасывается исключение-наследник `bank::transfer_error` с детальным `what()` и состояние гроссбуха не меняется.
2. **Блокирующий итератор**.
   Добавьте возможность потокобезопасно отслеживать транзакции пользователя в блокирующем режиме при помощи класса `bank::user_transaction_iterator`:
    * Метод `wait_next_transaction()` блокируется до появления очередной транзакции у пользователя и возвращает её.
    * Должна быть возможность за одну атомарную операцию посмотреть на текущее состояние пользователя и создать `bank::user_transaction_iterator`.
      В противном случае некоторые транзакции могут потеряться между чтением состояния и созданием итератора.
3. **Сетевой сервер**.
   Напишите TCP-сервер, который создаёт один гроссбух и позволяет TCP-клиентам побыть пользователями банка
   через протокол с состоянием ([stateful protocol](https://en.wikipedia.org/w/index.php?title=Stateful_protocol&redirect=no)):
    * Каждый TCP-клиент подключается как один из пользователей и действует от его имени.
    * Поддерживаются все методы класса `bank::user`, а также сообщения об ошибках.
    * Используйте `boost::asio::ip::tcp::iostream` для блокирующего взаимодействия с сетью.
    * TCP-клиенты могут в любой момент подключаться и отключаться, один пользователь может управляться одновременно несколькими клиентами.

Точные поддерживаемые методы смотрите в тестах, а тонкости их семантики — в требованиях ниже.

### Советы
* Выполняйте части сверху вниз.
  * В первой части (гроссбух) вам потребуются только `std::mutex` и `std::unique_lock`.
  * Во второй части (блокирующий итератор) добавится `std::condition_variable`.
  * В третьей части добавится `std::thread` и `boost::asio::ip::tcp`.
* Чётко распишите, что у вас защищено какими мьютексами и за какие условия отвечает условная переменная.
* Будьте осторожны с deadlock'ами, их очень просто получить при переводе денег от пользователя к пользователю.
* Не рассчитывайте, что выданные автотесты поймают все многопоточные проблемы.
* Воспользуйтесь thread sanitizer.
* Если пишите свои автотесты — делайте их большими и с кучей потоков, которые пытаются одновременно и писать, и читать один и тот же ресурс.
* Для отладки сетевого сервера используйте `netcat`.
* Обратите внимание, что блокировка мьютекса не `noexcept`.
* Помните, что для корректного общения с TCP-клиентом необходимо сбрасывать буфер
  и регулярно проверять, корректны ли потоки ввода-вывода (вдруг клиент отключился).
* Если класс `bank::ledger` скучный — развлекитесь с `emplace_hint` и `piecewise_construct`.

### Лирическое отступление
* Операции чтения в многопоточных программах редки, но тут они есть из учебных соображений.
  * Например, если мы прочитали баланс пользователя при помощи `.balance_xts()`, то мы не можем эти данные никак использовать: баланс мог только что измениться в другом потоке.
  * Аналогичная проблема есть и с методом `.monitor()`: мы не знаем, с какого момента мы реально начали следить за транзакциями.
  * Поэтому обычно требуются более высокоуровневые сложные методы вроде `snapshot_transactions`.
* Так как деньги могут измеряться по-разному, ко всем методам и переменным дописан суффикс — единица измерения `_xts`.
  * Здесь одна единица измерения и запутаться сложно, но в более сложных программах это важнее.
    Например: `timeout_millis`, `timeout_micros`, `timeout_ms` (милли или микро?), `timeout_sec`.
* Автоматические тесты на многопоточность написаны немного коряво:
  * Из не-главного потока никогда не вызываются `CHECK`/`REQUIRE`, несмотря на то, что `doctest` потокобезопасен.
    Вместо этого данные только собираются, а проверяются уже в главном потоке.
  * Это сделано, чтобы можно было запускать автотесты под MinGW.
    Там нужная конструкция `thread_local` плохо работает последние лет десять (то есть всегда),
    из-за чего doctest (и другие библиотеки) [могут падать под отладчиком](https://github.com/onqtam/doctest/issues/501#issuecomment-827577621).

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).
Обратите внимание, что состояние гонки (race condition) — UB и запрещается, даже если не стреляет.

При запуске под Valgrind решение компилируется с флагом `-DSMALL_TESTS`, чтобы тесты стали чуть поменьше.

### Дополнительные требования
* Если несколько потоков работают с непересекающимися подмножествами пользователей, они не должны друг другу мешать.
    * В частности, создать один глобальный мьютекс на все операции со всеми пользователями не прокатит.
* Запрещается использовать блокирующий ввод-вывод под мьютексом — он может зависнуть на неопределённое время.
    * Подсказка: осторожно со `snapshot_transactions`.
* Разные виды исключений должны иметь разные классы.

#### Запрещённые приёмы
Нарушение любого из требований ниже обнуляет баллы в соответствующей части и зависящих от неё.

* Запрещено костылить синхронизацию потоков через `std::this_thread::sleep_for` и похожие трюки.
* Блокирующий итератор должен, как правило, использовать блокирующее ожидание (например, через условную переменную), а не активное.

### Гроссбух
Экземпляр класа `bank::ledger` владеет пользователями соответствующего гроссбуха.
Метод `get_or_create_user(name)` атомарно возвращает ссылку на пользователя `name`.
Если этого пользователя ещё не было, то он добавляется в гроссбух.
Пользователи в памяти не перемещаются, так что можно использовать указатель на пользователя как идентификатор.

Каждый пользователь может сообщить потокобезопасно и за константное время:
* Своё имя: `.name()`
* Текущий баланс: `.balance_xts()`, помещается в `int` и неотрицателен.

Также должна быть возможность потокобезопасно посмотреть на часть транзакций пользователя, не копируя их все.
Для этого метод `.snapshot_transactions(f)` принимает функтор `f` и вызывает его под мьютексом,
передав в качестве параметров транзакции и текущий баланс.
Так можно прочитать любую часть транзакций без вмешательства со стороны остальных потоков.
Баланс нужно передавать, чтобы `f` мог его узнать за константное время без вызова `.balance_xts()` (иначе потребуется reentrant mutex).

Вы можете хранить транзакции и передавать их параметру `snapshot_transactions(f)`
в произвольном последовательном контейнере.
Старые транзакции идут в начале.
Транзакция должна представляться структурой `bank::transaction` с константными публичными полями:
* `counterparty` — указатель на пользователя-вторую сторону транзакции или `nullptr`,
  если эта сторона — сам банк (при исходном зачислении денег).
* `balance_delta_xts` — на сколько изменился баланс пользователя от транзакции.
* `comment` — произвольный комментарий к транзакции.

Метод `.transfer(counterparty, amount_xts, comment)` у пользователя `user`
атомарно переводит `amount_xts` XTS пользователю `counterparty`.
После этого у каждого пользователя должна появиться ровно одна новая транзакция.
Если это сделать невозможно — должно вылететь исключение-наследник класса `bank::transfer_error`
с подробностями.
Если `user` не хватает денег, то должно вылететь исключение `bank::not_enough_funds_error`
с фиксированным сообщением (смотри тесты).
Это не единственная возможная при переводе ошибка, остальные вам надо сообразить самостоятельно
исходя из здравого смысла и требований задания.

### Блокирующий итератор
Метод `snapshot_transactions(f)` теперь, помимо доступа к транзакциям, атомарно возвращает
экземпляр класса `user_transactions_iterator`.
Этот итератор имеет единственный метод `wait_next_transaction`, который блокируется,
пока не появится очередная транзакция, и возвращает её.
Так как `snapshot_transactions()` работает атомарно, это позволяет любому потоку
полностью знать состояние любого пользователя.

Может существовать несколько независимых итераторов одновременно.

Также к `bank::user` добавляется метод `monitor()`, который просто возвращает итератор,
позволяющий ждать новых транзакций.
Он используется в некоторых тестах, но вообще [является плохим API](#лирическое-отступление).

### Сетевой сервер
Консольное приложение запускается так:

```
./bank-server <port> <port-file>
```

При запуске сразу создаётся TCP-сервер на порту `<port>`.
`<port>` может быть равен нулю, это так и надо передать в конструктор `tcp::endpoint`,
тогда `tcp::acceptor` выберет случайный свободный порт — это удобно для автоматического
тестирования нескольких решений на одной машине параллельно.
Выбранный порт сервера требуется сохранить в файл `<port-file>`.
Если не удалось — выведите в стандартный поток ошибок сообщение `Unable to store port to file <port-file>`.

Сервер создает себе один глобальный гроссбух, с которым работают все клиенты.

Все сообщения сервера выводятся в стандартный поток ввода, сбрасывать буфер после очередного сообщения обязательно:

* В начале работы выведите сообщение `Listening at <endpoint>`,
  где `<endpoint>` — `acceptor.local_endpoint()`, где доступен сервер локально.
* При подключении клиента выведите сообщение `Connected <remote> --> <local>`,
  где `<remote>` и `<local>` — `remote_endpoint()` и `local_endpoint()` для клиента, соответственно.
  `local_endpoint()` будет частным случаем `acceptor.local_endpoint()`.
* При отключении клиента (по любой причине) выведите аналогичное `Disconnected <remote> --> <local>`.

Все TCP-клиенты обрабатываются параллельно в разных потоках.
Если какой-то клиент отключается, с остальными ничего не происходит.
Все ответы сервера завершаются переводом строки.
Каждому клиенту соответствует один банковский пользователь,
имена всех пользователей непустые и состоят из символов с кодами 33-127.
Сессия с каждым клиентом начинается с авторизации пользователя:

* Сервер: `What is your name?\n`.
* Клиент: `<username>` и пробельный символ.
* Сервер: `Hi <username>\n`.

Дальше сервер ожидает команд от клиента.
Команды отделяются друг от друга и аргументов пробельными символами:

* `balance`.
  Ответ — одно целое число (текущий баланс пользователя) и перевод строки.
* `transactions <n>`.
  Ответ — `n` последних транзакций пользователя на `n+1` строках.
  * Точный формат смотрите в тесте `run-test-server.py`.
  * Ячейки в строчке таблицы разделяются одним символом табуляции.
  * Гарантируется, что `<n>` неотрицательно и помещается в `int`.
  * Если транзакций меньше `n`, то выводятся все транзакции пользователя.
* `monitor <n>`.
  Аналогично `transactions <n>`, но после последней транзакции
  сервер не ждёт следующую команду, а начинает бесконечно выводить поток транзакций
  пользователя.
  * Это позволяет "в реальном времени" следить за своими транзакциями.
  * Из этой команды нельзя выйти.
* `transfer <counterparty> <amount> <comment>` — перевод пользователю.
  * Между `<amount>` и `<comment>` имеется ровно один пробельный символ,
    `<comment>` непусто и завершается `\n`.
  * В частности, `<comment>` может содержать пробелы: `transfer Bob 100 Some real comment`.
  * Ответ — `OK\n` в случае успешного перевода или сообщение об ошибке из `.what()` с переводом строки,
    если перевод неуспешен.
* Любая другая команда. Ответ — `Unknown command: '<введённая-команда>'\n`.
  * Например, если пользователь ввёл `hello world\n`, то это трактуется как две неизвестные команды: `hello` и `world`.

## Бонусное задание
Это задание можно сдавать только если вы выполнили все части основного задания.

Используйте вместо обычных мьютексов [`std::shared_mutex`](https://en.cppreference.com/w/cpp/thread/shared_mutex),
чтобы разрешить нескольким потокам одновременно читать константные данные.
Например, это может быть ускорением, если к одному пользователю постоянно обращаются
на чтение, а записи редки.
В этом задании это сомнительный сценарий, но в других многопоточных приложениях может встретиться.

## Инструкция по сдаче
[Как и раньше](../common/), вы должны самостоятельно синхронизировать ветку
`master` в своём репозитории, создать новую ветку для задания и новый Pull Request.

Если вы хотите сдать только некоторые части задания, закомментируйте остальные:

* Если вы также не пишете [блокирующий итератор](#блокирующий-итератор),
  закомментируйте строку `#define TEST_USER_TRANSACTION_ITERATOR` в файле `bank_test.cpp`
* Если вы не пишете [сетевой сервер](#сетевой-сервер),
  замените в файле `run-test-server.py` строку с вызовом `main()` на `pass`.

## Система оценки
* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы получаете ноль за часть и связанные с ней, если используете [запрещённые приёмы](#запрещённые-приёмы).
* Вы можете сдать любой префикс частей:
  * Только [гроссбух](#гроссбух) оценивается в 4/10 баллов: 2 за корректность, 2 за стиль.
  * Если у вас работает гроссбух, вы можете сдать [блокирующий итератор](#блокирующий-итератор) и получить ещё 3 балла (в сумме 7/10): 2 за корректность и 1 за стиль.
  * Если у вас работают первые три части, вы можете сделать ещё и [сетевой сервер](#сетевой-сервер), чтобы получить последние 3 балла: 2 за корректность и 1 за стиль.
  * Так как части взаимосвязаны, баллы на стиль могут распределяться между частями нечётко.
    Например, добавление блокирующего итератора может случайно испортить стиль гроссбуха.
* Если вы выполнили все части, вы можете получить ещё +4 балла за [бонусное задание](#бонусное-задание), итого 14.

## Сроки сдачи
Черновик выдан 27 апреля 2021 (вторник), окончательная версия выдана 11 мая 2021 (вторник).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 21 мая 2021 (пятница), **22**:59.
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений.
  * Дедлайн исправлений обговаривается индивидуально с проверяющим, в общем случае хотя бы пять суток.
  * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
